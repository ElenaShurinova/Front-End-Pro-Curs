# README

## Итоговое занятие №17

### Тема:

Репозитарий содержит материалы по занятию, посвященному работе с библиотекой `react-hook-form`.

### Цели занятия
- повторение и закрепление знаний;
- решение задач.

### Библиотека react-hook-form
**Обработка ошибок в библиотеке react-hook-form**
На прошлом занятии, мы разбирались с тем, как работает библиотека `react-hook-form`. Мы разобрали возможность добавления валидации на поля. Но валидация не имеет смысла, если мы никак не уведомляем пользователя об ошибках, которые возникли в поле ввода. Сегодня поговорим как это исправить.

Хук `useForm`, как мы уже выяснили, предоставлет нам инструменты `register`, `handleSubmit`. Но кроме этого, есть еще ряд полезных свойств. Одно из них - свойство `formState`, которое содержит свойство `errors`. И это свойство содержит объект с ошибками, случившимися в инпутах. Свойствами этого объекта будут имена инпутов. А значения этих свойств - объекты с информацией об ошибках.

Пока не понятно, попробуем разобрать подробнее. У нас есть компонент `SimpleForm`, который содержит несколько инпутов. Они зарегистрированы в библиотеке. Давайте добавим на некоторые из них валидацию:
 - поле `name` сделаем обязательным
 - полю `email` зададим шаблон
 - полю `phone` зададим минимальную длину (5 символов), и кастомную функцию валидации, которая содержит просто проверку на то, что значение содержит 10 символов.

```
  <input type='text' placeholder='Name' {...register('name', { required: true } )} />
  <input type='text' placeholder='Email' {...register('email', { pattern: /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/ } )} />
  <input type='text' placeholder='Phone' {...register('phone', { minLength: 5, validate: (value) => value.length === 10 } )} />
```

Также, мы добавим в деструктуризацию результата хука `useForm` свойство `formState.errors`. И на каждый ререндер компонента, будем выводить его в консоль.

```
  const { register, handleSubmit, formState: {errors} } = useForm();
  console.log(errors);
```

Попробуем выполнить сабмит формы, не заполняя поля. Мы видим, что в консоль вывелся объект (следовательно, компонент перерисовался). И видим свойства объекта.
```
{
  name: {
    type: 'required',
    ref: ...,
    message: ''
  },
  phone: {
    type: 'validate',
    ref: ...,
    message: ''
  }
}
```

То есть, объект содержит данные о тех инпутах, которые не прошли валидацию. Каждое свойство содержит ссылку на инпут (свойство `ref`), свойство `type` - то есть тип валидации, которая не прошла, и свойство `message` - это должно быть сообщение об ошибке. Пока что оно пустое - потому что мы его просто не задали. Попробуем это исправить - мы можем его задать при регистрации инпута. Давайте сделаем на примере инпута `name` - пусть сообщение об обязательности поля будет вида `Hey, this is required field!`.

```
  <input type='text' placeholder='Name' {...register('name', { required: { value: true, message: 'Hey, this is required field!' } } )} />
```

Что изменилось? Раньше, в свойстве `required` объекта настроек при регистрации инпута, мы задавали значение true - то есть просто маркировали инпут как обязательный. Теперь, мы ставим туда объект, у которого есть свойство `value` - то есть обязательное поле или нет, и свойство `message` - то есть сообщение об ошибке, которое возникнет, если инпут не будет заполнен.

Таким образом, мы можем задавать кастомные сообщения об ошибках "на все случаи жизни". Рассмотрим пример с полем телефона: пусть он должен быть обязательным, мин.длина 5 символов, макс.длина - 10 символов, и кастомная валидация - что он содержит цифру 0. Каждое правило валидации будет содержать свое сообщение.

```
  <input
    type='text'
    placeholder='Phone'
    {...register('phone', {
      required: { value: true, message: 'Enter your phone now!' },
      minLength: { value: 5, message: 'Too short!' },
      maxLength: { value: 10, message: 'Too long!' },
      validate: { shouldContain0: (fldVal) => fldVal.includes('0') || 'This field should contain 0!' }
    } )} />
```

Особое внимание заслуживает кастомная валидация. В этом случае, значение свойства `validate` содержит объект. Этот объект должен содержать свойства, имена которых соответствуют пользовательским именам правил валидации (что хотим, то туда и пишем). А значениями д.б. функции, которые возвращают `true` если правило валидации выполняется, ИЛИ возвращают строку с текстом ошибки. Этот объект может содержать столько свойств, сколько правил валидации мы захотим применить.

**Закрепим практикой**
1. Добавьте валидацию на инпут номера телефона в компоненте `SimpleForm`. Сделайте так, чтобы у него была минимальная длина 5, и соответствие шаблону /^0\d{9}$/. Тексты ошибок - `Too short`, `Incorrect phone format!`, соответственно.
2. Сделайте емейл обязательным, текст сообщения об ошибке - `Please, enter your email!`.
3. Добавьте инпуту `name` кастомную валидацию, чтобы поле не содержало пробелов. Текст ошибки - `Spaces are not allowed here!`.

**Отображение ошибок**
Теперь вопрос, как же нам отрисовывать ошибки, то бишь дать пользователю знать, в каком инпуте случился косяк. И здесь нам помогут свойство `formState.errors`, и условный рендеринг.

```
<input type='text' placeholder='Email' {...register('email', { pattern: /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/ } )} />
{ formState.errors.email && <p>{formState.errors.email.message}</p>}
```

То есть, если у нас поле емейла содержит ошибку, мы покажем под ним параграф с текстом этой ошибки. Вот и вся валидация!

И есть возможность сбросить ошибки всей формы, или конкретного инпута, для этого нам нужно воспользоваться инструментом `clearErrors`. Его мы также берем деструктуризацией результата работы хука `useForm`.

```
const { register, handleSubmit, formState: {errors}, clearErrors } = useForm();

// ...
return (
  // ...
  <button onClick={clearErrors}>Clear form errors</button>
)
```

Нажатие на кнопку очистит ошибки формы (то есть уберет сообщения об ошибках и сбросит валидацию).

**Практическое задание**
Создадим компонент для регистрации пользователя. Нам нужно запросить от него:
 - имя (обязательное поле, мин.длина 3 символа, макс.длина - 20 символов)
 - фамилию (обязательное, мин. - 3, макс. - 20)
 - емейл (необязательное, шаблон /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/ )
 - номер телефона (обязательное, шаблон /^0\d{9}$/)
 - тип учетной записи (выпадающий список с 3 значениями: basic, advanced, pro). Обязательное поле. Ему сделать кастомную валидацию. Если указаны типы advanced, pro - то должен быть заполнен емейл.

Для каждого правила валидации, должны быть свои (соответствующие) тексты ошибок. Рендерим тексты ошибок в виде параграфов под инпутами.

Также, в компоненте нужно добавить кнопку "Сброс", которая будет очищать все ошибки.

### Полезные ссылки
[Использование рефов](https://react.dev/learn/referencing-values-with-refs#) - работа с рефами как с хранилищем.
[Императивная работа с DOM](https://react.dev/learn/manipulating-the-dom-with-refs) - работа с DOM напрямую.
[Хук useRef](https://react.dev/reference/react/useRef) - информативно, с интерактивными примерами.
[Библиотека react-hook-form](https://www.react-hook-form.com/get-started/) - официальная документация проекта. Очень информативная, и с примерами.