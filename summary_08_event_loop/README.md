 # README

## Итоговое занятие №8

### Тема:

Репозитарий содержит материалы по итоговому занятию №8, посвященному работе с объектами, и асинхронным операциям в JS.

### Разогрев
1. Что выведет код?
```
console.log('First');
const myPromise = new Promise( (resolve, reject) => {
  resolve('Result');
})
.catch( err => console.log(err))
.then( result => {
  console.log(result);
});
console.log('Third');
```

2. Что выведет код?
```
console.log('First');
const myPromise = new Promise( (resolve, reject) => {
  reject('Result');
})
.then( result => {
  console.log(result);
})
.catch( err => console.log(err));
console.log('Third');
```

3. Что выведет код?
```
console.log('First');
const myPromise = new Promise( (resolve, reject) => {
  resolve('Result');
})
.finally( () => console.log('Finally'))
.catch( err => console.log(err))
.then( result => {
  console.log(result);
});
console.log('Third');
```

4. Что выведет код?
```
console.log('First');
const myPromiseVariable = new Promise( (resolve, reject) => {
  resolve('Result');
})
.catch( err => console.log(err))
.then( result => {
  return result;
});
console.log('Third');
```


### Задачи занятия

Решим задачи, которые остались с лекции.

1. Пишем сетевой запрос. Наша задача - обратиться к "бэку" по адресу `https://dummyjson.com/products/categories` GET-запросом, и вывести в консоль результат в "удобоваримом" виде (результат нам возвращается в виде JSON). Этот запрос нам вернет массив с категориями товаров.
2. Оборачиваем этот запрос в функцию `getCategories`. То есть у нас будет АСИНХРОННАЯ функция, которая должна сделать запрос по адресу из п.1, дождаться результата, преобразовать результат в JSON, дождаться результата, и потом дать возможность вызывающему коду работать с этим результатом.
3. Добавляем в разметку ПЕРЕД блоком `.productsContainer` компонент `select` (выпадающее меню). Нужно заполнить этот `select` опциями (`<option value='value'>option_text</option>`), которые нам пришли с "бэка" в предыдущей задаче. То есть, пройтись по массиву результатов, для каждого создать элемент `option`, и добавить его в наш `select`. В качестве `value` используем значение, в качестве `option_text` используем то же.
4. Пишем функцию `getProducts`. В качестве аргумента, она принимает категорию товаров. Она должна сделать запрос по адресу `https://dummyjson.com/products/category/ИМЯ_КАТЕГОРИИ`. В ответ нам придет список товаров этой категории. Наша задача - отрендерить их в списке товаров (`div.productsContainer`).  ВАЖНО! Список товаров перед рендерингом надо очистить! Товары рендерим с помощью функции `renderProduct`, она умеет создавать DOM-элемент, но нужно его еще добавить в контейнер.
5. Дорабатываем функцию `getProducts`. Нужно добавить рассмотрение случая, когда у нас не задана категория (хотим запросить все товары). Нужно сделать так, чтобы, если в аргументе не передана категория, то запрос шел на адрес `https://dummyjson.com/products`.
6. Добавляем обработчик события `change` на наш `select`. При событии, нам нужно вызывать функцию из п.12 с соответствующей категорией - т.е. мы рисуем список товаров выбранной категории.
7. Добавляем "иконку загрузки" на нашу страницу. Добавляем перед нашим `select` контейнер (`div.loader`) с текстом "Подождите, идет загрузка...". По умолчанию он скрыт (`display: none`). Нам нужно показывать этот блок при начале запроса списка товаров, и скрывать, когда список товаров успешно загружен.


### Теоретический блок, Event Loop

Как мы уже рассмотрели ранее, JS является однопоточным языком. Тем не менее, мы говорим об асинхронном коде, который выполняется как-то иначе, чем синхронный (имитация параллельного выполнения). Попробуем разобраться, как это происходит.

Прежде всего, определим понятие "очередь". Очередь - это структура данных, организованная по принципу "FIFO - First In First Out", то есть первый пришел - первый ушел. Что это значит? Это значит, что события, которые складываются в очередь, обрабатываются в порядке поступления: сначала обрабатываем того, кто первым был добавлен в очередь, далее второго, и т.д.

Теперь, свяжем это понятие с нашим контекстом. В веб-приложениях, браузер постоянно выполняет какие-то задачи. Это создание и обработка событий, выполнение скриптов, реакция на действия пользователя, и т.д. Эти задачи выполняются браузером в порядке поступления, то есть в порядке очереди. Можно сравнить это со "списком дел", в который постоянно добавляются дела, и браузер постоянно это выполняет.  Это все - синхронный код, с которым мы уже знакомы. Он будет выполняться немедленно, без задержек, в порядке объявления команд.

Давайте разберемся с `setTimeout`, как же он работает. Как мы ранее говорили, если мы планируем какую-то задачу с использованием таймаута, то она будет выполнена асинхронно. Когда мы вызываем `setTimeout`, движок создает новую **макрозадачу**, и кладет ее в конец очереди **макрозадач**. Термин "макрозадача" - это термин из документации, не стоит в него особо вникать. Ключевой момент здесь - **очередь мкарозадач**.

Рассмотрим на примере.
```
// очередь макрозадач пуста

console.log('First'); // синхронный код (1)

setTimeout( () => { // кладем задачу в конец очереди макрозадач
  console.log('timeout'); // (3)
}, 100);

console.log('Second'); // синхронный код (2)
```

Что же произойдет? Мы уже знаем, что сначала выполнится синхронный код (в порядке объявления команд) - то есть (1), затем (2). А дальше будет выполнена макрозадача (3). То есть будет вывод вида First - Second - timeout.

Если у нас будет несколько таймаутов, или интервал/несколько интервалов, то в очереди макрозадач будет та логика, которую они планируют, и выполняться она будет в порядке поступления.
```
// очередь макрозадач пуста

console.log('First'); // синхронный код (1)

setTimeout( () => { // кладем задачу в конец очереди макрозадач
  console.log('quick timeout'); // (3)
}, 100);
setTimeout( () => { // кладем задачу в конец очереди макрозадач
  console.log('longer timeout'); // (4)
}, 200);

console.log('Second'); // синхронный код (2)
```

Тут вывод будет First - Second - quick timeout - longer timeout. Потому что в очередь макрозадач сначала попадет первый таймаут (100мс), а затем второй (200мс).

И теперь пришла пора поговорить о промисах, пока что у нас только они остались неохваченными. Как же выполняются промисы? И кто будет выполнен первым: промис, или таймаут?

Для обработчиков промисов существует отдельная, специальная очередь. Потому что промисы именуются **микрозадачами**. Тоже мутный термин, вникать в него особо не надо - просто нужно понимать, что микро- и макро-задачи это разные вещи. И вот для микрозадач существует своя очередь. В нее события тоже поступают в порядке возникновения.

Осталось понять, каким образом осуществляется синхронизация между очередями, кто выполняется первее, и как.

И вот тут в дело вступает **событийный цикл**. Порядок обработки будет следующий:
1. Выполнить весь синхронный код.
2. Выполнить ВСЕ задачи из очереди **микрозадач** в порядке поступления.
3. Взять из очереди **макрозадач** самую старую, выполнить ее.
4. Перейти к шагу 2.

**ВАЖНО!** Это ОЧЕНЬ упрощенное понимание работы событийного цикла. К тому же, рассмотрены не все возможности работы с микрозадачами, например еще есть метод `queueMicrotask`. Поэтому желающие разобраться дополнительно приглашаются прочесть информацию из полезной ссылки.

**Закрепим практикой**
В задачах далее, нужно сказать, в какой последовательности мы увидим вывод в консоли.

1.
```
console.log('Start');

const myPromise = new Promise( (resolve, reject) => {
  resolve('Promise Result');
});
myPromise.then( res => console.log(res) );

console.log('Finish');
```

2.
```
console.log('Start');

const myPromise = new Promise( (resolve, reject) => {
  resolve('Promise Result');
});

setTimeout( () => console.log('Timeout'), 0 );

myPromise.then(res => console.log(res) );

console.log('Finish');
```

3.
```
console.log('Start');

const myPromise = new Promise( (resolve, reject) => {
  resolve('Promise Result');
});
const secondPromise = new Promise( (resolve, reject) => {
  resolve('Second Promise Result');
});

setTimeout( () => console.log('Timeout'), 0 );

myPromise.then(res => console.log(res) );
secondPromise.then(res => console.log(res) );

console.log('Finish');
```

### Полезные ссылки
 - [Event Loop](https://learn.javascript.ru/event-loop) - обязательно к ознакомлению.